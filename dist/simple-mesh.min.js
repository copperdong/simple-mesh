/*!
* SimpleMesh
* Copyright (c) 2017 Eric Johnson
* Version 1.0.0
* Licensed under the MIT license
* http://ericjohnson.me
*/'use strict';var _typeof=typeof Symbol==='function'&&typeof Symbol.iterator==='symbol'?function(obj){return typeof obj}:function(obj){return obj&&typeof Symbol==='function'&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':typeof obj};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if('value'in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor}}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError('Cannot call a class as a function')}}var Edge=function(){// eslint-disable-line no-unused-vars
function Edge(opts){_classCallCheck(this,Edge);if(opts==undefined)throw new Error('You must pass an `opts` argument to the Edge constructor');if(!opts.id)throw new Error('You must pass an `id` option to the Edge constructor');if(!opts.a)throw new Error('You must pass an `a` option to the Edge constructor');if(!opts.b)throw new Error('You must pass an `b` option to the Edge constructor');this.id=opts.id;this.a=opts.a;this.b=opts.b}_createClass(Edge,[{key:'draw',value:function draw(ctx,style,fog){ctx.beginPath();ctx.moveTo(this.a.x,this.a.y);ctx.lineTo(this.b.x,this.b.y);ctx.lineCap=style.lineCap;ctx.lineWidth=style.lineWidth;ctx.strokeStyle=style.strokeStyle;ctx.stroke();// Calculate the z-index fog
if(fog){var grad=ctx.createLinearGradient(this.a.x,this.a.y,this.b.x,this.b.y);grad.addColorStop(0,this.generateRgbZ(this.a.z));grad.addColorStop(1,this.generateRgbZ(this.b.z));ctx.strokeStyle=grad;ctx.stroke()}}/* Helper to build an RBG string based on z-index */},{key:'generateRgbZ',value:function generateRgbZ(z){var r=Math.round(100+z*0.5);var g=Math.round(100+z*0.5);var b=Math.round(100+z*0.5);return'rgb('+r+', '+g+', '+b+')'}}]);return Edge}();// Export on server only
if(typeof module!=='undefined'&&typeof module.exports!=='undefined'){module.exports=Edge}'use strict';var Face=function(){// eslint-disable-line no-unused-vars
function Face(opts){_classCallCheck(this,Face);if(opts==undefined)throw new Error('You must pass an `opts` argument to the Face constructor');if(!opts.id)throw new Error('You must pass an `id` option to the Face constructor');if(!opts.vertices)throw new Error('You must pass a `vertices` option to the Face constructor');this.id=opts.id;this.vertices=opts.vertices;if(opts.fillStyle)this.fillStyle=opts.fillStyle}_createClass(Face,[{key:'draw',value:function draw(ctx,style,origin){// Plot the shape
var first=true;ctx.beginPath();for(var id in this.vertices){var vertex=this.vertices[id];if(first){ctx.moveTo(vertex.x,vertex.y);first=false}else{ctx.lineTo(vertex.x,vertex.y)}}ctx.closePath();// Paint the face
if(this.fillStyle){ctx.fillStyle=this.fillStyle(origin)}else{ctx.fillStyle=style.fillStyle}ctx.fill()}}]);return Face}();// Export on server only
if(typeof module!=='undefined'&&typeof module.exports!=='undefined'){module.exports=Face}'use strict';var SimpleMesh=function(){// eslint-disable-line no-unused-vars
function SimpleMesh(context,opts){_classCallCheck(this,SimpleMesh);if(!context)throw new Error('A `context` argument is required');var defaults={fog:false,origin:{x:0,y:0,z:0},theta:{x:0,y:0,z:0},// Rotation angles in +/- degrees
vertices:{},// Vertex container
vertexVisibility:false,vertexStyle:{fillStyle:'#000000',strokeStyle:'#ffffff',lineWidth:1,radius:3,labelVisibility:true,labelOffset:{x:5,y:5},labelFillStyle:'#000000',labelStrokeStyle:'#ffffff',labelLineWidth:2,labelTextFillStyle:'#000000'},edges:{},// Edge container
edgeVisibility:true,edgeStyle:{strokeStyle:'#000000',lineWidth:1,lineCap:'round'},faces:{},// Face container
faceVisibility:true,faceStyle:{fillStyle:'#cc0000'}};this.deepExtend(this,defaults,opts);this.context=context;// Don't want this property subject to extension
this.validate();return this}_createClass(SimpleMesh,[{key:'deepExtend',value:function deepExtend(){for(var i=arguments.length-1;i>0;i--){var source=arguments[i];var dest=arguments[i-1];for(var prop in source){if(_typeof(source[prop])=='object'&&!Array.isArray(source[prop])){if(!dest.hasOwnProperty(prop))dest[prop]={};dest[prop]=this.deepExtend(dest[prop],source[prop])}else{dest[prop]=source[prop]}}}return arguments[0]}},{key:'validate',/* Validate properties */value:function validate(){if(typeof this.fog!='boolean')throw'The "fog" property must be boolean';if(_typeof(this.origin)!='object')throw'The "origin" property must be an object';if(typeof this.origin.x!='number')throw'The "origin.x" property must be a number';if(typeof this.origin.y!='number')throw'The "origin.y" property must be a number';if(typeof this.origin.z!='number')throw'The "origin.z" property must be a number';if(_typeof(this.theta)!='object')throw'The "theta" property must be an object';if(typeof this.theta.x!='number')throw'The "theta.x" property must be a number';if(typeof this.theta.y!='number')throw'The "theta.y" property must be a number';if(typeof this.theta.z!='number')throw'The "theta.z" property must be a number';if(typeof this.vertexVisibility!='boolean')throw'The "vertexVisibility" property must be boolean';if(_typeof(this.vertexStyle)!='object')throw'The "vertexStyle" property must be an object';if(typeof this.edgeVisibility!='boolean')throw'The "edgeVisibility" property must be boolean';if(_typeof(this.edgeStyle)!='object')throw'The "edgeStyle" property must be an object';if(typeof this.faceVisibility!='boolean')throw'The "faceVisibility" property must be boolean';if(_typeof(this.faceStyle)!='object')throw'The "faceStyle" property must be an object'}/* Load objects */},{key:'loadObjects',value:function loadObjects(opts){// Vertices
if(opts.hasOwnProperty('vertices')){for(var id in opts.vertices){opts.vertices[id].id=id;this.vertices[id]=new Vertex(opts.vertices[id])}}// Edges
if(opts.hasOwnProperty('edges')){for(var _id in opts.edges){var edge=opts.edges[_id];// Make certain the vertices are a real
if(this.vertices[edge.a]=='undefined')throw'A is not a vertex';if(this.vertices[edge.b]=='undefined')throw'B is not a vertex';edge.id=_id;edge.a=this.vertices[edge.a];edge.b=this.vertices[edge.b];//
this.edges[_id]=new Edge(edge)}}// Faces
if(opts.hasOwnProperty('faces')){for(var faceId in opts.faces){var face=opts.faces[faceId];face.id=faceId;for(var vertexId in face.vertices){var vertex=face.vertices[vertexId];face.vertices[vertexId]=this.vertices[vertex]}this.faces[faceId]=new Face(face)}}}},{key:'loadArrays',/* Load simple arrays */value:function loadArrays(obj){if(obj.vertices==null)throw'An array of vertices must is required';// Require vertices
var verticeOrder=[];// Store the vertex order for loading edges
// Loop over the array of vertices
for(var i in obj.vertices){// Set the vertex to our container obj with a unique id
// and if successful, push into our stored order
var id=null;do{id=this.generateUniqueId();if(this.vertices.hasOwnProperty(id)){console.log('Id "'+id+'" is already a vertex! Generating a new id...');id=null}else{this.vertices[id]=new Vertex({id:id,x:obj.vertices[i][0],y:obj.vertices[i][1],z:obj.vertices[i][2],parent:this});verticeOrder.push(id)}}while(id==null)}// Loop over the array of edges (if set)
for(var _i in obj.edges){var aI=obj.edges[_i][0];var bI=obj.edges[_i][1];var a=verticeOrder[aI];var b=verticeOrder[bI];// Make an edge
var _id2=null;do{_id2=this.generateUniqueId();if(this.edges.hasOwnProperty(_id2)){console.log('Id "'+_id2+'" is already an edge! Generating a new id...');_id2=null}else{this.edges[_id2]=new Edge({id:_id2,a:this.vertices[a],b:this.vertices[b],parent:this})}}while(_id2==null)}}},{key:'scale',/* Expand or contract a mesh based on a numeric factor */value:function scale(factor){// Require a numeric factor
if(typeof factor!='number')throw'Factor "'+factor+'" must be numeric';// Loop over the vertices and multiply
for(var i in this.vertices){var vertex=this.vertices[i];vertex.x=vertex.oX=vertex.x*factor;vertex.y=vertex.oY=vertex.y*factor;vertex.z=vertex.oZ=vertex.z*factor}}/* translate */},{key:'translate',value:function translate(origin){for(var id in this.vertices){var vertex=this.vertices[id];vertex.x+=origin.x;vertex.y+=origin.y;vertex.y*=-1;// Reverse Y
vertex.z+=origin.z}}/* Reset the rotation angles */},{key:'reset',value:function reset(){for(var id in this.vertices){var vertex=this.vertices[id];vertex.x=vertex.oX;vertex.y=vertex.oY;vertex.z=vertex.oZ}}},{key:'draw',/* Render the mesh */value:function draw(){// Rotate
this.rotateX(this.theta.x);this.rotateY(this.theta.y);this.rotateZ(this.theta.z);// Translate
this.translate(this.origin);// Draw faces
if(this.faceVisibility){for(var id in this.faces){this.faces[id].draw(this.context,this.faceStyle,this.origin)}}// Draw edges
if(this.edgeVisibility){for(var _id3 in this.edges){this.edges[_id3].draw(this.context,this.edgeStyle,this.fog)}}// Draw vertices
if(this.vertexVisibility){for(var _id4 in this.vertices){this.vertices[_id4].draw(this.context,this.vertexStyle)}}this.reset()}},{key:'rotateX',value:function rotateX(theta){this.rotate('y','z',theta)}},{key:'rotateY',value:function rotateY(theta){this.rotate('x','z',theta)}},{key:'rotateZ',value:function rotateZ(theta){this.rotate('x','y',theta)}/* Perform a matrix rotation on all vertices */},{key:'rotate',value:function rotate(a,b,theta){// Validate
var axes=['x','y','z'];if(axes.indexOf(a)<0)throw'Axis A must be one of x, y, or z';if(axes.indexOf(b)<0)throw'Axis B must be one of x, y, or z';if(typeof theta!='number')throw'Theta must be numeric';// Perform a matrix rotation
var radians=Math.PI/180*theta;for(var id in this.vertices){var vertex=this.vertices[id];// Buffer the values before assigning
var tempA=vertex[a]*Math.cos(radians)-vertex[b]*Math.sin(radians);var tempB=vertex[a]*Math.sin(radians)+vertex[b]*Math.cos(radians);vertex[a]=tempA;vertex[b]=tempB}}},{key:'generateUniqueId',/* Helper to generate a randomized 5 char Id */value:function generateUniqueId(){var id='';var chars='abcdefghijklmnopqrstuvwxyz0123456789';for(var i=0;i<5;i++){id+=chars.charAt(Math.floor(Math.random()*chars.length))}return id}}]);return SimpleMesh}();// Export on server only
if(typeof module!=='undefined'&&typeof module.exports!=='undefined'){module.exports=SimpleMesh}'use strict';var Vertex=function(){// eslint-disable-line no-unused-vars
function Vertex(opts){_classCallCheck(this,Vertex);if(opts==undefined)throw new Error('You must pass an `opts` argument to the Vertex constructor');if(opts.hasOwnProperty('id')==false)throw new Error('You must pass an `id` option to the Vertex constructor');if(opts.hasOwnProperty('x')==false)throw new Error('You must pass an `x` option to the Vertex constructor');if(opts.hasOwnProperty('y')==false)throw new Error('You must pass a `y` option to the Vertex constructor');if(opts.hasOwnProperty('z')==false)throw new Error('You must pass a `z` option to the Vertex constructor');this.id=opts.id;this.oX=opts.x;this.oY=opts.y;this.oZ=opts.z;this.x=opts.x;this.y=opts.y;this.z=opts.z}_createClass(Vertex,[{key:'draw',value:function draw(ctx,style){// Draw the circle
ctx.beginPath();ctx.arc(this.x,this.y,style.radius,0,2*Math.PI,false);ctx.closePath();// Style the circle
ctx.lineWidth=style.lineWidth;ctx.fillStyle=style.fillStyle;ctx.strokeStyle=style.strokeStyle;ctx.fill();ctx.stroke();// Draw the label
if(style.labelVisibility){var x=this.x+style.labelOffset.x;var y=this.y-style.labelOffset.y;ctx.lineWidth=style.labelLineWidth;ctx.strokeStyle=style.labelStrokeStyle;ctx.fillStyle=style.labelFillStyle;ctx.strokeText(this.id,x,y);ctx.fillText(this.id,x,y)}}}]);return Vertex}();// Export on server only
if(typeof module!=='undefined'&&typeof module.exports!=='undefined'){module.exports=Vertex}
//# sourceMappingURL=simple-mesh.min.js.map
