{"version":3,"sources":["Edge.js","Face.js","SimpleMesh.js","Vertex.js","simple-mesh.min.js"],"names":["Edge","opts","undefined","Error","id","a","b","ctx","style","fog","beginPath","moveTo","x","y","lineTo","lineCap","lineWidth","strokeStyle","stroke","grad","createLinearGradient","addColorStop","generateRgbZ","z","r","Math","round","g","module","exports","Face","vertices","fillStyle","origin","first","vertex","closePath","fill","SimpleMesh","context","defaults","theta","vertexVisibility","vertexStyle","radius","labelVisibility","labelOffset","labelFillStyle","labelStrokeStyle","labelLineWidth","labelTextFillStyle","edges","edgeVisibility","edgeStyle","faces","faceVisibility","faceStyle","deepExtend","validate","i","arguments","length","source","dest","prop","Array","isArray","hasOwnProperty","Vertex","edge","faceId","face","vertexId","obj","verticeOrder","generateUniqueId","console","log","parent","push","aI","bI","factor","oX","oY","oZ","rotateX","rotateY","rotateZ","translate","draw","reset","rotate","axes","indexOf","radians","PI","tempA","cos","sin","tempB","chars","charAt","floor","random","arc","strokeText","fillText"],"mappings":"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","file":"simple-mesh.min.js","sourcesContent":["'use strict';\n\nclass Edge { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Edge constructor');\n        if (!opts.id) throw new Error('You must pass an `id` option to the Edge constructor');\n        if (!opts.a) throw new Error('You must pass an `a` option to the Edge constructor');\n        if (!opts.b) throw new Error('You must pass an `b` option to the Edge constructor');\n\n        this.id = opts.id;\n        this.a = opts.a;\n        this.b = opts.b;\n    }\n\n    draw (ctx, style, fog) {\n        ctx.beginPath();\n        ctx.moveTo(this.a.x, this.a.y);\n        ctx.lineTo(this.b.x, this.b.y);\n\n        ctx.lineCap = style.lineCap;\n        ctx.lineWidth = style.lineWidth;\n        ctx.strokeStyle = style.strokeStyle;\n        ctx.stroke();\n\n        // Calculate the z-index fog\n        if (fog) {\n            const grad = ctx.createLinearGradient(this.a.x, this.a.y, this.b.x, this.b.y);\n            grad.addColorStop(0, this.generateRgbZ(this.a.z));\n            grad.addColorStop(1, this.generateRgbZ(this.b.z));\n            ctx.strokeStyle = grad;\n            ctx.stroke();\n        }\n    }\n\n    /* Helper to build an RBG string based on z-index */\n    generateRgbZ (z) {\n        const r = Math.round(100 + (z * 0.5));\n        const g = Math.round(100 + (z * 0.5));\n        const b = Math.round(100 + (z * 0.5));\n\n        return `rgb(${r}, ${g}, ${b})`;\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Edge;\n}\n","'use strict';\n\nclass Face { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Face constructor');\n        if (!opts.id) throw new Error('You must pass an `id` option to the Face constructor');\n        if (!opts.vertices) throw new Error('You must pass a `vertices` option to the Face constructor');\n\n        this.id = opts.id;\n        this.vertices = opts.vertices;\n        if (opts.fillStyle) this.fillStyle = opts.fillStyle;\n    }\n\n    draw (ctx, style, origin) {\n        // Plot the shape\n        let first = true;\n        ctx.beginPath();\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            if (first) {\n                ctx.moveTo(vertex.x, vertex.y);\n                first = false;\n            } else {\n                ctx.lineTo(vertex.x, vertex.y);\n            }\n        }\n        ctx.closePath();\n\n        // Paint the face\n        if (this.fillStyle) {\n            ctx.fillStyle = this.fillStyle(origin);\n        } else {\n            ctx.fillStyle = style.fillStyle;\n        }\n        ctx.fill();\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Face;\n}\n","'use strict';\n\nclass SimpleMesh { // eslint-disable-line no-unused-vars\n    constructor (context, opts) {\n        if (!context) throw new Error('A `context` argument is required');\n\n        const defaults = {\n            fog              : false,\n            origin           : { x : 0, y : 0, z : 0 },\n            theta            : { x : 0, y : 0, z : 0 }, // Rotation angles in +/- degrees\n            vertices         : {}, // Vertex container\n            vertexVisibility : false,\n            vertexStyle      : {\n                fillStyle          : '#000000',\n                strokeStyle        : '#ffffff',\n                lineWidth          : 1,\n                radius             : 3,\n                labelVisibility    : true,\n                labelOffset        : { x : 5, y : 5 },\n                labelFillStyle     : '#000000',\n                labelStrokeStyle   : '#ffffff',\n                labelLineWidth     : 2,\n                labelTextFillStyle : '#000000'\n            },\n            edges          : {}, // Edge container\n            edgeVisibility : true,\n            edgeStyle      : {\n                strokeStyle : '#000000',\n                lineWidth   : 1,\n                lineCap     : 'round'\n            },\n            faces          : {}, // Face container\n            faceVisibility : true,\n            faceStyle      : {\n                fillStyle : '#cc0000'\n            }\n        };\n\n        this.deepExtend(this, defaults, opts);\n        this.context = context; // Don't want this property subject to extension\n        this.validate();\n\n        return this;\n    }\n\n    deepExtend () {\n        for (let i = arguments.length - 1; i > 0; i--) {\n            const source = arguments[i];\n            const dest = arguments[i - 1];\n            for (const prop in source) {\n                if (typeof source[prop] == 'object' && !Array.isArray(source[prop])) {\n                    if (!dest.hasOwnProperty(prop)) dest[prop] = {};\n                    dest[prop] = this.deepExtend(dest[prop], source[prop]);\n                } else {\n                    dest[prop] = source[prop];\n                }\n            }\n        }\n        return arguments[0];\n    };\n\n    /* Validate properties */\n    validate () {\n        if (typeof this.fog != 'boolean') throw 'The \"fog\" property must be boolean';\n        if (typeof this.origin != 'object') throw 'The \"origin\" property must be an object';\n        if (typeof this.origin.x != 'number') throw 'The \"origin.x\" property must be a number';\n        if (typeof this.origin.y != 'number') throw 'The \"origin.y\" property must be a number';\n        if (typeof this.origin.z != 'number') throw 'The \"origin.z\" property must be a number';\n        if (typeof this.theta != 'object') throw 'The \"theta\" property must be an object';\n        if (typeof this.theta.x != 'number') throw 'The \"theta.x\" property must be a number';\n        if (typeof this.theta.y != 'number') throw 'The \"theta.y\" property must be a number';\n        if (typeof this.theta.z != 'number') throw 'The \"theta.z\" property must be a number';\n        if (typeof this.vertexVisibility != 'boolean') throw 'The \"vertexVisibility\" property must be boolean';\n        if (typeof this.vertexStyle != 'object') throw 'The \"vertexStyle\" property must be an object';\n        if (typeof this.edgeVisibility != 'boolean') throw 'The \"edgeVisibility\" property must be boolean';\n        if (typeof this.edgeStyle != 'object') throw 'The \"edgeStyle\" property must be an object';\n        if (typeof this.faceVisibility != 'boolean') throw 'The \"faceVisibility\" property must be boolean';\n        if (typeof this.faceStyle != 'object') throw 'The \"faceStyle\" property must be an object';\n    }\n\n    /* Load objects */\n    loadObjects (opts) {\n        // Vertices\n        if (opts.hasOwnProperty('vertices')) {\n            for (const id in opts.vertices) {\n                opts.vertices[id].id = id;\n                this.vertices[id] = new Vertex(opts.vertices[id]);\n            }\n        }\n\n        // Edges\n        if (opts.hasOwnProperty('edges')) {\n            for (const id in opts.edges) {\n                const edge = opts.edges[id];\n\n                // Make certain the vertices are a real\n                if (this.vertices[edge.a] == 'undefined') throw 'A is not a vertex';\n                if (this.vertices[edge.b] == 'undefined') throw 'B is not a vertex';\n\n                edge.id = id;\n                edge.a = this.vertices[edge.a];\n                edge.b = this.vertices[edge.b];\n\n                //\n                this.edges[id] = new Edge(edge);\n            }\n        }\n\n        // Faces\n        if (opts.hasOwnProperty('faces')) {\n            for (const faceId in opts.faces) {\n                const face = opts.faces[faceId];\n                face.id = faceId;\n                for (const vertexId in face.vertices) {\n                    const vertex = face.vertices[vertexId];\n                    face.vertices[vertexId] = this.vertices[vertex];\n                }\n                this.faces[faceId] = new Face(face);\n            }\n        }\n    };\n\n    /* Load simple arrays */\n    loadArrays (obj) {\n        if (obj.vertices == null) throw 'An array of vertices must is required'; // Require vertices\n        const verticeOrder = []; // Store the vertex order for loading edges\n\n        // Loop over the array of vertices\n        for (const i in obj.vertices) {\n            // Set the vertex to our container obj with a unique id\n            // and if successful, push into our stored order\n            let id = null;\n            do {\n                id = this.generateUniqueId();\n                if (this.vertices.hasOwnProperty(id)) {\n                    console.log(`Id \"${id}\" is already a vertex! Generating a new id...`);\n                    id = null;\n                } else {\n                    this.vertices[id] = new Vertex({\n                        id,\n                        x      : obj.vertices[i][0],\n                        y      : obj.vertices[i][1],\n                        z      : obj.vertices[i][2],\n                        parent : this\n                    });\n                    verticeOrder.push(id);\n                }\n            } while (id == null);\n        }\n\n        // Loop over the array of edges (if set)\n        for (const i in obj.edges) {\n            const aI = obj.edges[i][0];\n            const bI = obj.edges[i][1];\n            const a = verticeOrder[aI];\n            const b = verticeOrder[bI];\n\n            // Make an edge\n            let id = null;\n            do {\n                id = this.generateUniqueId();\n                if (this.edges.hasOwnProperty(id)) {\n                    console.log(`Id \"${id}\" is already an edge! Generating a new id...`);\n                    id = null;\n                } else {\n                    this.edges[id] = new Edge({\n                        id,\n                        a      : this.vertices[a],\n                        b      : this.vertices[b],\n                        parent : this\n                    });\n                }\n            } while (id == null);\n        }\n    };\n\n    /* Expand or contract a mesh based on a numeric factor */\n    scale (factor) {\n        // Require a numeric factor\n        if (typeof factor != 'number') throw `Factor \"${factor}\" must be numeric`;\n\n        // Loop over the vertices and multiply\n        for (const i in this.vertices) {\n            const vertex = this.vertices[i];\n            vertex.x = vertex.oX = vertex.x * factor;\n            vertex.y = vertex.oY = vertex.y * factor;\n            vertex.z = vertex.oZ = vertex.z * factor;\n        }\n    }\n\n    /* translate */\n    translate (origin) {\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            vertex.x += origin.x;\n            vertex.y += origin.y;\n            vertex.y *= -1; // Reverse Y\n            vertex.z += origin.z;\n        }\n    }\n\n    /* Reset the rotation angles */\n    reset () {\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            vertex.x = vertex.oX;\n            vertex.y = vertex.oY;\n            vertex.z = vertex.oZ;\n        }\n    };\n\n    /* Render the mesh */\n    draw () {\n        // Rotate\n        this.rotateX(this.theta.x);\n        this.rotateY(this.theta.y);\n        this.rotateZ(this.theta.z);\n\n        // Translate\n        this.translate(this.origin);\n\n        // Draw faces\n        if (this.faceVisibility) {\n            for (const id in this.faces) {\n                this.faces[id].draw(this.context, this.faceStyle, this.origin);\n            }\n        }\n\n        // Draw edges\n        if (this.edgeVisibility) {\n            for (const id in this.edges) {\n                this.edges[id].draw(this.context, this.edgeStyle, this.fog);\n            }\n        }\n\n        // Draw vertices\n        if (this.vertexVisibility) {\n            for (const id in this.vertices) {\n                this.vertices[id].draw(this.context, this.vertexStyle);\n            }\n        }\n\n        this.reset();\n    }\n\n    rotateX (theta) {\n        this.rotate('y', 'z', theta);\n    }\n\n    rotateY (theta) {\n        this.rotate('x', 'z', theta);\n    }\n\n    rotateZ (theta) {\n        this.rotate('x', 'y', theta);\n    }\n\n    /* Perform a matrix rotation on all vertices */\n    rotate (a, b, theta) {\n        // Validate\n        const axes = [ 'x', 'y', 'z' ];\n        if (axes.indexOf(a) < 0) throw 'Axis A must be one of x, y, or z';\n        if (axes.indexOf(b) < 0) throw 'Axis B must be one of x, y, or z';\n        if (typeof theta != 'number') throw 'Theta must be numeric';\n\n        // Perform a matrix rotation\n        const radians = Math.PI / 180 * theta;\n\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            // Buffer the values before assigning\n            const tempA = ((vertex[a] * Math.cos(radians)) - (vertex[b] * Math.sin(radians)));\n            const tempB = ((vertex[a] * Math.sin(radians)) + (vertex[b] * Math.cos(radians)));\n            vertex[a] = tempA;\n            vertex[b] = tempB;\n        }\n    };\n\n    /* Helper to generate a randomized 5 char Id */\n    generateUniqueId () {\n        let id = '';\n        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\n        for (let i = 0; i < 5; i++) {\n            id += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n\n        return id;\n    };\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = SimpleMesh;\n}\n","'use strict';\n\nclass Vertex { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Vertex constructor');\n        if (opts.hasOwnProperty('id') == false) throw new Error('You must pass an `id` option to the Vertex constructor');\n        if (opts.hasOwnProperty('x') == false) throw new Error('You must pass an `x` option to the Vertex constructor');\n        if (opts.hasOwnProperty('y') == false) throw new Error('You must pass a `y` option to the Vertex constructor');\n        if (opts.hasOwnProperty('z') == false) throw new Error('You must pass a `z` option to the Vertex constructor');\n\n        this.id = opts.id;\n        this.oX = opts.x;\n        this.oY = opts.y;\n        this.oZ = opts.z;\n        this.x = opts.x;\n        this.y = opts.y;\n        this.z = opts.z;\n    }\n\n    draw (ctx, style) {\n        // Draw the circle\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, style.radius, 0, 2 * Math.PI, false);\n        ctx.closePath();\n\n        // Style the circle\n        ctx.lineWidth = style.lineWidth;\n        ctx.fillStyle = style.fillStyle;\n        ctx.strokeStyle = style.strokeStyle;\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw the label\n        if (style.labelVisibility) {\n            const x = this.x + style.labelOffset.x;\n            const y = this.y - style.labelOffset.y;\n\n            ctx.lineWidth = style.labelLineWidth;\n            ctx.strokeStyle = style.labelStrokeStyle;\n            ctx.fillStyle = style.labelFillStyle;\n            ctx.strokeText(this.id, x, y);\n            ctx.fillText(this.id, x, y);\n        }\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Vertex;\n}\n","/*!\n* SimpleMesh\n* Copyright (c) 2017 Eric Johnson\n* Version 1.0.0\n* Licensed under the MIT license\n* http://ericjohnson.me\n*/'use strict';\n\nclass Edge { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Edge constructor');\n        if (!opts.id) throw new Error('You must pass an `id` option to the Edge constructor');\n        if (!opts.a) throw new Error('You must pass an `a` option to the Edge constructor');\n        if (!opts.b) throw new Error('You must pass an `b` option to the Edge constructor');\n\n        this.id = opts.id;\n        this.a = opts.a;\n        this.b = opts.b;\n    }\n\n    draw (ctx, style, fog) {\n        ctx.beginPath();\n        ctx.moveTo(this.a.x, this.a.y);\n        ctx.lineTo(this.b.x, this.b.y);\n\n        ctx.lineCap = style.lineCap;\n        ctx.lineWidth = style.lineWidth;\n        ctx.strokeStyle = style.strokeStyle;\n        ctx.stroke();\n\n        // Calculate the z-index fog\n        if (fog) {\n            const grad = ctx.createLinearGradient(this.a.x, this.a.y, this.b.x, this.b.y);\n            grad.addColorStop(0, this.generateRgbZ(this.a.z));\n            grad.addColorStop(1, this.generateRgbZ(this.b.z));\n            ctx.strokeStyle = grad;\n            ctx.stroke();\n        }\n    }\n\n    /* Helper to build an RBG string based on z-index */\n    generateRgbZ (z) {\n        const r = Math.round(100 + (z * 0.5));\n        const g = Math.round(100 + (z * 0.5));\n        const b = Math.round(100 + (z * 0.5));\n\n        return `rgb(${r}, ${g}, ${b})`;\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Edge;\n}\n\n'use strict';\n\nclass Face { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Face constructor');\n        if (!opts.id) throw new Error('You must pass an `id` option to the Face constructor');\n        if (!opts.vertices) throw new Error('You must pass a `vertices` option to the Face constructor');\n\n        this.id = opts.id;\n        this.vertices = opts.vertices;\n        if (opts.fillStyle) this.fillStyle = opts.fillStyle;\n    }\n\n    draw (ctx, style, origin) {\n        // Plot the shape\n        let first = true;\n        ctx.beginPath();\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            if (first) {\n                ctx.moveTo(vertex.x, vertex.y);\n                first = false;\n            } else {\n                ctx.lineTo(vertex.x, vertex.y);\n            }\n        }\n        ctx.closePath();\n\n        // Paint the face\n        if (this.fillStyle) {\n            ctx.fillStyle = this.fillStyle(origin);\n        } else {\n            ctx.fillStyle = style.fillStyle;\n        }\n        ctx.fill();\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Face;\n}\n\n'use strict';\n\nclass SimpleMesh { // eslint-disable-line no-unused-vars\n    constructor (context, opts) {\n        if (!context) throw new Error('A `context` argument is required');\n\n        const defaults = {\n            fog              : false,\n            origin           : { x : 0, y : 0, z : 0 },\n            theta            : { x : 0, y : 0, z : 0 }, // Rotation angles in +/- degrees\n            vertices         : {}, // Vertex container\n            vertexVisibility : false,\n            vertexStyle      : {\n                fillStyle          : '#000000',\n                strokeStyle        : '#ffffff',\n                lineWidth          : 1,\n                radius             : 3,\n                labelVisibility    : true,\n                labelOffset        : { x : 5, y : 5 },\n                labelFillStyle     : '#000000',\n                labelStrokeStyle   : '#ffffff',\n                labelLineWidth     : 2,\n                labelTextFillStyle : '#000000'\n            },\n            edges          : {}, // Edge container\n            edgeVisibility : true,\n            edgeStyle      : {\n                strokeStyle : '#000000',\n                lineWidth   : 1,\n                lineCap     : 'round'\n            },\n            faces          : {}, // Face container\n            faceVisibility : true,\n            faceStyle      : {\n                fillStyle : '#cc0000'\n            }\n        };\n\n        this.deepExtend(this, defaults, opts);\n        this.context = context; // Don't want this property subject to extension\n        this.validate();\n\n        return this;\n    }\n\n    deepExtend () {\n        for (let i = arguments.length - 1; i > 0; i--) {\n            const source = arguments[i];\n            const dest = arguments[i - 1];\n            for (const prop in source) {\n                if (typeof source[prop] == 'object' && !Array.isArray(source[prop])) {\n                    if (!dest.hasOwnProperty(prop)) dest[prop] = {};\n                    dest[prop] = this.deepExtend(dest[prop], source[prop]);\n                } else {\n                    dest[prop] = source[prop];\n                }\n            }\n        }\n        return arguments[0];\n    };\n\n    /* Validate properties */\n    validate () {\n        if (typeof this.fog != 'boolean') throw 'The \"fog\" property must be boolean';\n        if (typeof this.origin != 'object') throw 'The \"origin\" property must be an object';\n        if (typeof this.origin.x != 'number') throw 'The \"origin.x\" property must be a number';\n        if (typeof this.origin.y != 'number') throw 'The \"origin.y\" property must be a number';\n        if (typeof this.origin.z != 'number') throw 'The \"origin.z\" property must be a number';\n        if (typeof this.theta != 'object') throw 'The \"theta\" property must be an object';\n        if (typeof this.theta.x != 'number') throw 'The \"theta.x\" property must be a number';\n        if (typeof this.theta.y != 'number') throw 'The \"theta.y\" property must be a number';\n        if (typeof this.theta.z != 'number') throw 'The \"theta.z\" property must be a number';\n        if (typeof this.vertexVisibility != 'boolean') throw 'The \"vertexVisibility\" property must be boolean';\n        if (typeof this.vertexStyle != 'object') throw 'The \"vertexStyle\" property must be an object';\n        if (typeof this.edgeVisibility != 'boolean') throw 'The \"edgeVisibility\" property must be boolean';\n        if (typeof this.edgeStyle != 'object') throw 'The \"edgeStyle\" property must be an object';\n        if (typeof this.faceVisibility != 'boolean') throw 'The \"faceVisibility\" property must be boolean';\n        if (typeof this.faceStyle != 'object') throw 'The \"faceStyle\" property must be an object';\n    }\n\n    /* Load objects */\n    loadObjects (opts) {\n        // Vertices\n        if (opts.hasOwnProperty('vertices')) {\n            for (const id in opts.vertices) {\n                opts.vertices[id].id = id;\n                this.vertices[id] = new Vertex(opts.vertices[id]);\n            }\n        }\n\n        // Edges\n        if (opts.hasOwnProperty('edges')) {\n            for (const id in opts.edges) {\n                const edge = opts.edges[id];\n\n                // Make certain the vertices are a real\n                if (this.vertices[edge.a] == 'undefined') throw 'A is not a vertex';\n                if (this.vertices[edge.b] == 'undefined') throw 'B is not a vertex';\n\n                edge.id = id;\n                edge.a = this.vertices[edge.a];\n                edge.b = this.vertices[edge.b];\n\n                //\n                this.edges[id] = new Edge(edge);\n            }\n        }\n\n        // Faces\n        if (opts.hasOwnProperty('faces')) {\n            for (const faceId in opts.faces) {\n                const face = opts.faces[faceId];\n                face.id = faceId;\n                for (const vertexId in face.vertices) {\n                    const vertex = face.vertices[vertexId];\n                    face.vertices[vertexId] = this.vertices[vertex];\n                }\n                this.faces[faceId] = new Face(face);\n            }\n        }\n    };\n\n    /* Load simple arrays */\n    loadArrays (obj) {\n        if (obj.vertices == null) throw 'An array of vertices must is required'; // Require vertices\n        const verticeOrder = []; // Store the vertex order for loading edges\n\n        // Loop over the array of vertices\n        for (const i in obj.vertices) {\n            // Set the vertex to our container obj with a unique id\n            // and if successful, push into our stored order\n            let id = null;\n            do {\n                id = this.generateUniqueId();\n                if (this.vertices.hasOwnProperty(id)) {\n                    console.log(`Id \"${id}\" is already a vertex! Generating a new id...`);\n                    id = null;\n                } else {\n                    this.vertices[id] = new Vertex({\n                        id,\n                        x      : obj.vertices[i][0],\n                        y      : obj.vertices[i][1],\n                        z      : obj.vertices[i][2],\n                        parent : this\n                    });\n                    verticeOrder.push(id);\n                }\n            } while (id == null);\n        }\n\n        // Loop over the array of edges (if set)\n        for (const i in obj.edges) {\n            const aI = obj.edges[i][0];\n            const bI = obj.edges[i][1];\n            const a = verticeOrder[aI];\n            const b = verticeOrder[bI];\n\n            // Make an edge\n            let id = null;\n            do {\n                id = this.generateUniqueId();\n                if (this.edges.hasOwnProperty(id)) {\n                    console.log(`Id \"${id}\" is already an edge! Generating a new id...`);\n                    id = null;\n                } else {\n                    this.edges[id] = new Edge({\n                        id,\n                        a      : this.vertices[a],\n                        b      : this.vertices[b],\n                        parent : this\n                    });\n                }\n            } while (id == null);\n        }\n    };\n\n    /* Expand or contract a mesh based on a numeric factor */\n    scale (factor) {\n        // Require a numeric factor\n        if (typeof factor != 'number') throw `Factor \"${factor}\" must be numeric`;\n\n        // Loop over the vertices and multiply\n        for (const i in this.vertices) {\n            const vertex = this.vertices[i];\n            vertex.x = vertex.oX = vertex.x * factor;\n            vertex.y = vertex.oY = vertex.y * factor;\n            vertex.z = vertex.oZ = vertex.z * factor;\n        }\n    }\n\n    /* translate */\n    translate (origin) {\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            vertex.x += origin.x;\n            vertex.y += origin.y;\n            vertex.y *= -1; // Reverse Y\n            vertex.z += origin.z;\n        }\n    }\n\n    /* Reset the rotation angles */\n    reset () {\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            vertex.x = vertex.oX;\n            vertex.y = vertex.oY;\n            vertex.z = vertex.oZ;\n        }\n    };\n\n    /* Render the mesh */\n    draw () {\n        // Rotate\n        this.rotateX(this.theta.x);\n        this.rotateY(this.theta.y);\n        this.rotateZ(this.theta.z);\n\n        // Translate\n        this.translate(this.origin);\n\n        // Draw faces\n        if (this.faceVisibility) {\n            for (const id in this.faces) {\n                this.faces[id].draw(this.context, this.faceStyle, this.origin);\n            }\n        }\n\n        // Draw edges\n        if (this.edgeVisibility) {\n            for (const id in this.edges) {\n                this.edges[id].draw(this.context, this.edgeStyle, this.fog);\n            }\n        }\n\n        // Draw vertices\n        if (this.vertexVisibility) {\n            for (const id in this.vertices) {\n                this.vertices[id].draw(this.context, this.vertexStyle);\n            }\n        }\n\n        this.reset();\n    }\n\n    rotateX (theta) {\n        this.rotate('y', 'z', theta);\n    }\n\n    rotateY (theta) {\n        this.rotate('x', 'z', theta);\n    }\n\n    rotateZ (theta) {\n        this.rotate('x', 'y', theta);\n    }\n\n    /* Perform a matrix rotation on all vertices */\n    rotate (a, b, theta) {\n        // Validate\n        const axes = [ 'x', 'y', 'z' ];\n        if (axes.indexOf(a) < 0) throw 'Axis A must be one of x, y, or z';\n        if (axes.indexOf(b) < 0) throw 'Axis B must be one of x, y, or z';\n        if (typeof theta != 'number') throw 'Theta must be numeric';\n\n        // Perform a matrix rotation\n        const radians = Math.PI / 180 * theta;\n\n        for (const id in this.vertices) {\n            const vertex = this.vertices[id];\n            // Buffer the values before assigning\n            const tempA = ((vertex[a] * Math.cos(radians)) - (vertex[b] * Math.sin(radians)));\n            const tempB = ((vertex[a] * Math.sin(radians)) + (vertex[b] * Math.cos(radians)));\n            vertex[a] = tempA;\n            vertex[b] = tempB;\n        }\n    };\n\n    /* Helper to generate a randomized 5 char Id */\n    generateUniqueId () {\n        let id = '';\n        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n\n        for (let i = 0; i < 5; i++) {\n            id += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n\n        return id;\n    };\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = SimpleMesh;\n}\n\n'use strict';\n\nclass Vertex { // eslint-disable-line no-unused-vars\n    constructor (opts) {\n        if (opts == undefined) throw new Error('You must pass an `opts` argument to the Vertex constructor');\n        if (opts.hasOwnProperty('id') == false) throw new Error('You must pass an `id` option to the Vertex constructor');\n        if (opts.hasOwnProperty('x') == false) throw new Error('You must pass an `x` option to the Vertex constructor');\n        if (opts.hasOwnProperty('y') == false) throw new Error('You must pass a `y` option to the Vertex constructor');\n        if (opts.hasOwnProperty('z') == false) throw new Error('You must pass a `z` option to the Vertex constructor');\n\n        this.id = opts.id;\n        this.oX = opts.x;\n        this.oY = opts.y;\n        this.oZ = opts.z;\n        this.x = opts.x;\n        this.y = opts.y;\n        this.z = opts.z;\n    }\n\n    draw (ctx, style) {\n        // Draw the circle\n        ctx.beginPath();\n        ctx.arc(this.x, this.y, style.radius, 0, 2 * Math.PI, false);\n        ctx.closePath();\n\n        // Style the circle\n        ctx.lineWidth = style.lineWidth;\n        ctx.fillStyle = style.fillStyle;\n        ctx.strokeStyle = style.strokeStyle;\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw the label\n        if (style.labelVisibility) {\n            const x = this.x + style.labelOffset.x;\n            const y = this.y - style.labelOffset.y;\n\n            ctx.lineWidth = style.labelLineWidth;\n            ctx.strokeStyle = style.labelStrokeStyle;\n            ctx.fillStyle = style.labelFillStyle;\n            ctx.strokeText(this.id, x, y);\n            ctx.fillText(this.id, x, y);\n        }\n    }\n}\n\n// Export on server only\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Vertex;\n}\n"]}